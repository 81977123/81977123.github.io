# ROS1麦轮小车STM32代码模块详解

## 目录
1. [运动学模块](#1-运动学模块)
2. [PID控制模块](#2-pid控制模块)
3. [电机控制模块](#3-电机控制模块)
4. [编码器模块](#4-编码器模块)
5. [IMU模块](#5-imu模块)
6. [通信模块](#6-通信模块)
7. [系统框架](#7-系统框架)

## 1. 运动学模块

### 1.1 麦克纳姆轮原理
麦克纳姆轮由轮毂和周边成45°排列的辊子组成，通过四个轮子的不同转速组合，可以实现平面内的任意移动（前后、左右、旋转）。

### 1.2 运动学方程
正运动学（速度→轮速）：
```
[V1]   [1, 1, -(Lx+Ly)] [Vx]
[V2] = [1, -1, (Lx+Ly)] × [Vy]
[V3]   [1, -1, -(Lx+Ly)] [ω]
[V4]   [1, 1, (Lx+Ly)]
```
其中：
- V1~V4：四个轮子的线速度
- Vx, Vy：小车整体线速度
- ω：小车角速度
- Lx = 前后轮距/2
- Ly = 左右轮距/2

### 1.3 代码实现分析
```c
// Kinematics_Mecanum.c 中的关键函数

void Kinematics_Mecanum_CalculateRPM(Kinematics_Struct *Kinematics)
{
    // 从线速度、角速度计算轮子RPM
    float wheel_rps[4];
    
    // 计算每个轮子的线速度
    wheel_rps[0] = ( Kinematics->Linear_X 
                   + Kinematics->Linear_Y 
                   - (LR_WHEELS_DISTANCE/2 + FR_WHEELS_DISTANCE/2) 
                   * Kinematics->Angular_Z) / WHEEL_CIRCUMFERENCE;
    
    // 类似计算其他三个轮子...
    
    // 转换为RPM
    Kinematics->M1_RPM = wheel_rps[0] * 60.0f;
    // 其他轮子...
}
```

### 1.4 参数校准
1. **轮子周长测量**：
   ```c
   // 实际测量值替换
   #define WHEEL_CIRCUMFERENCE 实际测量值
   ```

2. **轮距测量**：
   - 左右轮中心距离
   - 前后轮中心距离

## 2. PID控制模块

### 2.1 PID算法原理
```
输出 = Kp×误差 + Ki×积分(误差) + Kd×微分(误差)
```

### 2.2 增量式PID实现
```c
float Incremental_PID(IncPID_Struct *PID, float NextPoint, float SetPoint)
{
    PID->Error = SetPoint - NextPoint;
    
    // 增量计算
    float increment = PID->Proportion * (PID->Error - PID->PrevError)
                    + PID->Integral * PID->Error
                    + PID->Derivative * (PID->Error - 2*PID->PrevError + PID->LastError);
    
    // 更新历史误差
    PID->LastError = PID->PrevError;
    PID->PrevError = PID->Error;
    
    return increment;
}
```

### 2.3 位置式PID实现
```c
float Position_PID(PosPID_Struct *PID, float NextPoint, float SetPoint)
{
    PID->Error = SetPoint - NextPoint;
    
    // 积分项（带限幅）
    PID->IntegralError += PID->Error;
    if (PID->IntegralError > PID->IntegralError_Max)
        PID->IntegralError = PID->IntegralError_Max;
    if (PID->IntegralError < PID->IntegralError_Min)
        PID->IntegralError = PID->IntegralError_Min;
    
    // 微分项
    float derivative = PID->Error - PID->PrevError;
    PID->PrevError = PID->Error;
    
    return PID->Proportion * PID->Error
         + PID->Integral * PID->IntegralError
         + PID->Derivative * derivative;
}
```

### 2.4 PID调参指南
| 现象 | 调整方法 | 预期效果 |
|------|---------|---------|
| 响应慢 | 增大Kp | 加快响应 |
| 超调大 | 减小Kp，增大Kd | 减少超调 |
| 稳态误差 | 增大Ki | 消除静差 |
| 振荡 | 减小Kp，增大Kd | 稳定系统 |

## 3. 电机控制模块

### 3.1 PWM控制原理
- **频率**：通常10-20kHz（超出人耳范围）
- **分辨率**：STM32定时器通常16位（0-65535）
- **占空比**：决定电机平均电压

### 3.2 电机驱动电路
```
STM32 PWM → 电机驱动芯片 → 电机
           ↓
       电流检测 → ADC → 过流保护
```

### 3.3 代码结构
```c
// MotorControl.c 关键函数

// 初始化
void Motor_Init(void)
{
    // 1. GPIO初始化（方向控制、使能）
    // 2. 定时器初始化（PWM输出）
    // 3. ADC初始化（电流检测）
    // 4. 保护机制初始化
}

// 设置速度
void Motor_SetSpeed(uint8_t motor_id, int16_t speed)
{
    // 1. 速度限幅
    if (speed > MAX_SPEED) speed = MAX_SPEED;
    if (speed < -MAX_SPEED) speed = -MAX_SPEED;
    
    // 2. 设置方向
    if (speed >= 0) {
        HAL_GPIO_WritePin(DIR_GPIO[motor_id], DIR_PIN[motor_id], GPIO_PIN_SET);
    } else {
        HAL_GPIO_WritePin(DIR_GPIO[motor_id], DIR_PIN[motor_id], GPIO_PIN_RESET);
        speed = -speed;
    }
    
    // 3. 设置PWM占空比
    uint16_t pwm_value = (speed * PWM_MAX) / MAX_SPEED;
    __HAL_TIM_SET_COMPARE(&htim, PWM_CHANNEL[motor_id], pwm_value);
}
```

## 4. 编码器模块

### 4.1 编码器类型
- **增量式编码器**：A、B两相，四倍频计数
- **绝对式编码器**：直接读取位置（本项目使用增量式）

### 4.2 定时器编码器模式
STM32定时器支持正交编码器接口，自动计数。

```c
// Encoder.c 初始化
void Encoder_Init(void)
{
    TIM_Encoder_InitTypeDef encoder_config = {0};
    
    encoder_config.EncoderMode = TIM_ENCODERMODE_TI12;  // 双相计数
    encoder_config.IC1Polarity = TIM_ICPOLARITY_RISING;
    encoder_config.IC2Polarity = TIM_ICPOLARITY_RISING;
    encoder_config.IC1Selection = TIM_ICSELECTION_DIRECTTI;
    encoder_config.IC2Selection = TIM_ICSELECTION_DIRECTTI;
    encoder_config.IC1Prescaler = TIM_ICPSC_DIV1;
    encoder_config.IC2Prescaler = TIM_ICPSC_DIV1;
    encoder_config.IC1Filter = 0;
    encoder_config.IC2Filter = 0;
    
    HAL_TIM_Encoder_Init(&htim3, &encoder_config);
    HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);
}
```

### 4.3 速度计算
```c
float Encoder_GetSpeed(uint8_t encoder_id)
{
    static int32_t last_count[4] = {0};
    static uint32_t last_time[4] = {0};
    
    int32_t current_count = TIM3->CNT;  // 读取计数值
    uint32_t current_time = HAL_GetTick();
    
    // 计算脉冲差
    int32_t pulse_diff = current_count - last_count[encoder_id];
    
    // 处理溢出（16位计数器）
    if (pulse_diff > 32767) pulse_diff -= 65536;
    if (pulse_diff < -32768) pulse_diff += 65536;
    
    // 计算时间差（ms）
    uint32_t time_diff = current_time - last_time[encoder_id];
    
    // 更新历史值
    last_count[encoder_id] = current_count;
    last_time[encoder_id] = current_time;
    
    // 计算速度（RPM）
    // 每转脉冲数 = 编码器线数 × 4（四倍频）
    float rpm = (pulse_diff * 60.0f * 1000.0f) / (ENCODER_PPR * 4 * time_diff);
    
    return rpm;
}
```

## 5. IMU模块

### 5.1 MPU6050寄存器配置
```c
// mpu6050.c 初始化序列
void MPU6050_Init(void)
{
    // 1. 唤醒设备
    MPU6050_WriteReg(MPU6050_PWR_MGMT_1, 0x00);
    HAL_Delay(100);
    
    // 2. 设置陀螺仪量程 ±2000°/s
    MPU6050_WriteReg(MPU6050_GYRO_CONFIG, 0x18);
    
    // 3. 设置加速度计量程 ±8g
    MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, 0x10);
    
    // 4. 设置采样率 1kHz
    MPU6050_WriteReg(MPU6050_SMPLRT_DIV, 0x07);
    
    // 5. 配置数字低通滤波器
    MPU6050_WriteReg(MPU6050_CONFIG, 0x06);
}
```

### 5.2 数据读取与处理
```c
void MPU6050_ReadData(MPU6050_Data *data)
{
    uint8_t buffer[14];
    
    // 读取14个字节（加速度+温度+陀螺仪）
    MPU6050_ReadRegs(MPU6050_ACCEL_XOUT_H, buffer, 14);
    
    // 转换加速度数据
    data->accel_x = (int16_t)((buffer[0] << 8) | buffer[1]);
    data->accel_y = (int16_t)((buffer[2] << 8) | buffer[3]);
    data->accel_z = (int16_t)((buffer[4] << 8) | buffer[5]);
    
    // 转换温度
    data->temperature = (int16_t)((buffer[6] << 8) | buffer[7]);
    
    // 转换陀螺仪数据
    data->gyro_x = (int16_t)((buffer[8] << 8) | buffer[9]);
    data->gyro_y = (int16_t)((buffer[10] << 8) | buffer[11]);
    data->gyro_z = (int16_t)((buffer[12] << 8) | buffer[13]);
    
    // 转换为实际单位
    data->accel_x_g = data->accel_x / ACCEL_SCALE;
    data->gyro_x_dps = data->gyro_x / GYRO_SCALE;
    // 其他轴类似...
}
```

### 5.3 姿态解算（简化版）
```c
// 互补滤波
void ComplementaryFilter(MPU6050_Data *raw, Attitude *attitude)
{
    static float angle_x = 0, angle_y = 0;
    
    // 从加速度计计算姿态角
    float accel_angle_x = atan2(raw->accel_y, raw->accel_z) * RAD_TO_DEG;
    float accel_angle_y = atan2(-raw->accel_x, sqrt(raw->accel_y*raw->accel_y + raw->accel_z*raw->accel_z)) * RAD_TO_DEG;
    
    // 从陀螺仪计算角度变化
    float gyro_rate_x = raw->gyro_x_dps;
    float gyro_rate_y = raw->gyro_y_dps;
    
    // 互补滤波融合
    float alpha = 0.98;  // 陀螺仪权重
    angle_x = alpha * (angle_x + gyro_rate_x * DT) + (1-alpha) * accel_angle_x;
    angle_y = alpha * (angle_y + gyro_rate_y * DT) + (1-alpha) * accel_angle_y;
    
    attitude->roll = angle_x;
    attitude->pitch = angle_y;
}
```

## 6. 通信模块

### 6.1 数据协议设计
```c
// DataProtocol.h
#pragma pack(1)  // 1字节对齐

typedef struct {
    uint8_t header;      // 帧头 0xAA
    uint8_t cmd;         // 命令字
    uint8_t length;      // 数据长度
    uint8_t data[32];    // 数据内容
    uint8_t checksum;    // 校验和
    uint8_t footer;      // 帧尾 0x55
} Protocol_Frame;

#pragma pack()  // 恢复默认对齐
```

### 6.2 命令解析
```c
void Protocol_Parse(uint8_t *buffer, uint8_t length)
{
    Protocol_Frame *frame = (Protocol_Frame *)buffer;
    
    // 检查帧头帧尾
    if (frame->header != 0xAA || frame->footer != 0x55) {
        return;  // 帧错误
    }
    
    // 校验和验证
    uint8_t calc_checksum = 0;
    for (int i = 0; i < frame->length + 3; i++) {  // header+cmd+length+data
        calc_checksum += buffer[i];
    }
    
    if (calc_checksum != frame->checksum) {
        return;  // 校验和错误
    }
    
    // 命令处理
    switch (frame->cmd) {
        case CMD_SET_VELOCITY:
            // 设置速度
            float vx = *(float*)&frame->data[0];
            float vy = *(float*)&frame->data[4];
            float wz = *(float*)&frame->data[8];
            SetTargetVelocity(vx, vy, wz);
            break;
            
        case CMD_GET_STATUS:
            // 发送状态
            SendStatusData();
            break;
            
        // 其他命令...
    }
}
```

### 6.3 ROS消息映射
```
ROS geometry_msgs/Twist → 自定义协议
    linear.x → vx (float, 4字节)
    linear.y → vy (float, 4字节)
    angular.z → wz (float, 4字节)
```

## 7. 系统框架

### 7.1 任务调度设计
```c
// Loop.c - 主循环任务调度
void MainLoop_Scheduler(void)
{
    static uint32_t last_time[10] = {0};
    uint32_t current_time = HAL_GetTick();
    
    // 1ms任务（最高优先级）
    if (current_time - last_time[0] >= 1) {
        Encoder_Update();      // 编码器读取
        last_time[0] = current_time;
    }
    
    // 10ms任务
    if (current_time - last_time[1] >= 10) {
        MPU6050_Read();        // IMU读取
        PID_Calculate();       // PID计算
        last_time[1] = current_time;
    }
    
    // 50ms任务
    if (current_time - last_time[2] >= 50) {
        Communication_Process();  // 通信处理
        Battery_Check();         // 电池检测
        last_time[2] = current_time;
    }
    
    // 100ms任务
    if (current_time - last_time[3] >= 100) {
        Send_Status();           // 状态发送
        Error_Check();           // 错误检查
        last_time[3] = current_time;
    }
}
```

### 7.2 中断优先级配置
| 中断源 | 优先级 | 说明 |
|--------|--------|------|
| 编码器定时器 | 0（最高） | 实时计数 |
| PWM定时器 | 1 | 电机控制 |
| 串口接收 | 2 | 通信数据 |
| 系统滴答 | 3 | 时间基准 |
| ADC转换完成 | 4 | 模拟量采集 |

### 7.3 内存使用优化
```c
// 使用DMA减少CPU负载
// 1. 串口收发使用DMA
// 2. ADC使用DMA连续采样
// 3. 电机PWM使用DMA更新

// 内存池管理
#define MEMORY_POOL_SIZE 1024
static uint8_t memory_pool[MEMORY_POOL_SIZE];
static uint16_t memory_index = 0;

void* Memory_Alloc(uint16_t size)
{
    if (memory_index + size > MEMORY_POOL_SIZE) {
        return NULL;  // 内存不足
    }
    
    void* ptr = &memory_pool[memory_index];
    memory_index += size;
    return ptr;
}

void Memory_Reset(void)
{
    memory_index = 0;
}
```

### 7.4 错误处理机制
```c
typedef enum {
    ERROR_NONE = 0,
    ERROR_MOTOR_OVERCURRENT,
    ERROR_BATTERY_LOW,
    ERROR_ENCODER_FAULT,
    ERROR_IMU_TIMEOUT,
    ERROR_COMMUNICATION_LOST
} Error_Code;

static Error_Code error_status = ERROR_NONE;

void Error_Handler(Error_Code error)
{
    error_status = error;
    
    // 记录错误日志
    Error_Log(error, HAL_GetTick());
    
    // 根据错误等级处理
    switch (error) {
        case ERROR_MOTOR_OVERCURRENT:
            Motor_StopAll();  // 紧急停止
            LED_Blink(FAST);  // 快速闪烁报警
            break;
            
        case ERROR_BATTERY_LOW:
            LED_Blink(SLOW);  // 慢速闪烁警告
            break;
            
        // 其他错误处理...
    }
    
    // 发送错误报告
    if (Communication_IsReady()) {
        Send_Error_Report(error);
    }
}
```

## 总结

本代码模块详解涵盖了麦轮小车STM32控制系统的核心部分。每个模块都有明确的功能划分和接口定义，便于维护和扩展。在实际开发中，建议：

1. **模块化测试**：逐个模块验证功能
2. **参数记录**：记录所有调整过的参数值
3. **版本控制**：使用Git管理代码版本
4. **文档更新**：代码修改时同步更新文档

通过深入理解这些模块，你可以更好地进行二次开发、故障排查和性能优化。