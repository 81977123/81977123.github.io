# ROS1麦轮小车STM32代码实践练习与实验

## 实验目标
通过一系列循序渐进的实验，从零开始掌握麦轮小车STM32代码的开发和调试。

## 实验环境准备

### 1.1 硬件清单
- [ ] STM32开发板（STM32F103系列）
- [ ] 4个直流电机+麦克纳姆轮
- [ ] 4个编码器
- [ ] MPU6050模块
- [ ] 蓝牙模块（HC-05/HC-06）
- [ ] 电机驱动板（如TB6612、DRV8833等）
- [ ] 12V锂电池
- [ ] USB转串口模块
- [ ] ST-Link下载器
- [ ] 万用表、示波器（可选但推荐）

### 1.2 软件安装
```bash
# 必需软件
1. Keil MDK-ARM 或 STM32CubeIDE
2. ST-Link Utility
3. 串口调试助手（Putty、SecureCRT等）
4. Git（版本控制）

# 可选工具
5. Logic Analyzer软件（如Saleae Logic）
6. Python环境（用于数据分析）
7. ROS1（用于上层控制）
```

## 实验一：开发环境搭建与第一个程序

### 实验目标
1. 成功编译现有项目
2. 下载程序到开发板
3. 运行第一个测试程序

### 实验步骤

#### 步骤1：打开工程
```bash
# 使用Keil MDK
1. 双击打开 MDK-ARM/STM32F103.uvprojx
2. 观察工程结构
```

#### 步骤2：编译测试
1. 点击"Rebuild All"按钮
2. 观察输出窗口，确认0错误0警告
3. 如果有错误，根据提示解决

#### 步骤3：连接硬件
1. ST-Link连接开发板
2. 开发板供电（USB或外部电源）
3. 确认连接状态

#### 步骤4：下载程序
1. 点击"Download"按钮
2. 观察下载进度，确认成功
3. 开发板自动运行程序

#### 步骤5：验证运行
1. 观察开发板LED是否闪烁
2. 如果没有LED闪烁，检查：
   - 电源是否正常
   - 复位按钮是否按下
   - 程序是否成功下载

### 实验记录表
| 步骤 | 预期结果 | 实际结果 | 问题与解决 |
|------|---------|---------|-----------|
| 编译 | 0错误0警告 | | |
| 下载 | 下载成功提示 | | |
| 运行 | LED闪烁 | | |

## 实验二：GPIO控制与LED测试

### 实验目标
1. 理解GPIO配置
2. 控制LED闪烁
3. 添加新的LED控制代码

### 实验内容

#### 任务1：查找现有LED代码
```c
// 在项目中搜索LED相关代码
// 使用Keil的"Find in Files"功能搜索：
// 关键词：LED, GPIO, HAL_GPIO
```

#### 任务2：修改闪烁频率
找到LED控制代码，修改延时时间：
```c
// 原始代码可能类似：
HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
HAL_Delay(500);  // 修改这个值

// 改为不同频率测试：
// 1. 快速闪烁：HAL_Delay(100);
// 2. 慢速闪烁：HAL_Delay(1000);
```

#### 任务3：添加新的LED模式
在`main.c`中添加新函数：
```c
void LED_TestPattern(void)
{
    // 模式1：流水灯效果
    for(int i=0; i<4; i++) {
        HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);
        HAL_Delay(200);
        HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
        // 类似控制其他LED...
    }
}
```

### 实验思考题
1. GPIO有几种工作模式？本项目中使用的是哪种？
2. 如何配置GPIO的上拉/下拉电阻？
3. 推挽输出和开漏输出有什么区别？

## 实验三：PWM控制与电机测试

### 实验目标
1. 理解PWM原理
2. 控制单个电机转动
3. 测试不同占空比对速度的影响

### 实验准备
1. 连接一个电机到电机驱动板
2. 电机驱动板连接到STM32
3. 确保电源连接正确

### 实验步骤

#### 步骤1：查找PWM配置
```c
// 在项目中搜索PWM相关代码
// 关键词：PWM, TIM, __HAL_TIM_SET_COMPARE
```

#### 步骤2：单电机测试程序
创建测试函数：
```c
void Motor_Test_Single(uint8_t motor_id)
{
    printf("测试电机 %d\n", motor_id);
    
    // 正转测试
    printf("正转50%%占空比\n");
    Motor_SetSpeed(motor_id, 500);
    HAL_Delay(2000);
    
    printf("正转100%%占空比\n");
    Motor_SetSpeed(motor_id, 1000);
    HAL_Delay(2000);
    
    // 反转测试
    printf("反转50%%占空比\n");
    Motor_SetSpeed(motor_id, -500);
    HAL_Delay(2000);
    
    // 停止
    printf("停止\n");
    Motor_SetSpeed(motor_id, 0);
    HAL_Delay(1000);
}
```

#### 步骤3：占空比-速度关系测试
```c
void Motor_SpeedCurve_Test(uint8_t motor_id)
{
    int16_t speeds[] = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000};
    int num_speeds = sizeof(speeds)/sizeof(speeds[0]);
    
    for(int i=0; i<num_speeds; i++) {
        Motor_SetSpeed(motor_id, speeds[i]);
        printf("设置占空比: %d\n", speeds[i]);
        
        HAL_Delay(1000);
        
        float rpm = Encoder_GetSpeed(motor_id);
        printf("实际转速: %.2f RPM\n", rpm);
        
        HAL_Delay(1000);
    }
    
    Motor_SetSpeed(motor_id, 0);
}
```

### 数据记录表
| 占空比(%) | 设定值 | 实际转速(RPM) | 备注 |
|-----------|--------|--------------|------|
| 10 | 100 | | |
| 20 | 200 | | |
| ... | ... | | |
| 100 | 1000 | | |

## 实验四：编码器读取与校准

### 实验目标
1. 读取编码器脉冲数
2. 计算电机实际转速
3. 校准编码器参数

### 实验步骤

#### 步骤1：手动测试编码器
```c
void Encoder_Manual_Test(uint8_t encoder_id)
{
    printf("手动旋转电机，观察编码器计数\n");
    
    int32_t last_count = Encoder_GetCount(encoder_id);
    
    for(int i=0; i<10; i++) {
        HAL_Delay(1000);
        int32_t current_count = Encoder_GetCount(encoder_id);
        int32_t diff = current_count - last_count;
        
        printf("时间: %ds, 计数: %ld, 差值: %ld\n", 
               i+1, current_count, diff);
        
        last_count = current_count;
    }
}
```

#### 步骤2：计算每转脉冲数(PPR)
```c
void Encoder_PPR_Calibration(uint8_t encoder_id)
{
    printf("请将电机旋转 exactly 1圈\n");
    
    int32_t start_count = Encoder_GetCount(encoder_id);
    
    printf("旋转电机1圈后...\n");
    // 等待用户旋转
    
    int32_t end_count = Encoder_GetCount(encoder_id);
    int32_t pulse_count = end_count - start_count;
    
    if (pulse_count < 0) pulse_count += 65536;
    
    float ppr = pulse_count / 4.0f;
    
    printf("原始脉冲数: %ld\n", pulse_count);
    printf("每转脉冲数(PPR): %.1f\n", ppr);
    printf("建议值: #define ENCODER_PPR %.0f\n", ppr);
}
```

#### 步骤3：速度计算验证
```c
void Encoder_Speed_Verification(uint8_t motor_id)
{
    Motor_SetSpeed(motor_id, 500);
    HAL_Delay(2000);
    
    float sum_rpm = 0;
    int samples = 10;
    
    for(int i=0; i<samples; i++) {
        float rpm = Encoder_GetSpeed(motor_id);
        sum_rpm += rpm;
        printf("采样%d: %.2f RPM\n", i+1, rpm);
        HAL_Delay(100);
    }
    
    float avg_rpm = sum_rpm / samples;
    printf("平均转速: %.2f RPM\n", avg_rpm);
    
    Motor_SetSpeed(motor_id, 0);
}
```

### 校准记录表
| 电机编号 | 实测PPR | 原配置PPR | 误差 | 建议修正值 |
|----------|---------|-----------|------|-----------|
| M1 | | | | |
| M2 | | | | |
| M3 | | | | |
| M4 | | | | |

## 实验五：PID参数整定

### 实验目标
1. 理解PID各参数作用
2. 手动整定PID参数
3. 达到稳定的速度控制

### 实验步骤

#### 步骤1：开环测试
```c
void PID_OpenLoop_Test(uint8_t motor_id)
{
    printf("开环测试 - 无PID控制\n");
    
    for(int duty=100; duty<=1000; duty+=100) {
        Motor_SetSpeed(motor_id, duty);
        HAL_Delay(2000);
        
        float rpm = Encoder_GetSpeed(motor_id);
        printf("占空比: %d, 转速: %.2f RPM\n", duty, rpm);
    }
    
    Motor_SetSpeed(motor_id, 0);
}
```

#### 步骤2：P参数整定
```c
void PID_P_Tuning(uint8_t motor_id)
{
    float target_rpm = 300.0f;
    
    float p_values[] = {0.1, 0.2, 0.5, 1.0, 2.0, 5.0};
    int num_tests = sizeof(p_values)/sizeof(p_values[0]);
    
    for(int i=0; i<num_tests; i++) {
        printf("\n测试P=%.2f\n", p_values[i]);
        PID_SetP(motor_id, p_values[i]);
        PID_SetI(motor_id, 0);
        PID_SetD(motor_id, 0);
        
        PID_Reset(motor_id);
        PID_SetTarget(motor_id, target_rpm);
        
        for(int t=0; t<50; t++) {
            float current_rpm = Encoder_GetSpeed(motor_id);
            printf("t=%d: 目标=%.1f, 实际=%.1f\n", 
                   t*100, target_rpm, current_rpm);
            HAL_Delay(100);
        }
        
        Motor_SetSpeed(motor_id, 0);
        HAL_Delay(1000);
    }
}
```

### PID整定记录表
| 测试序号 | P | I | D | 超调量(%) | 调节时间(s) | 稳态误差 | 评价 |
|----------|---|---|---|-----------|------------|----------|------|
| 1 | 0.5 | 0 | 0 | | | | |
| 2 | 1.0 | 0 | 0 | | | | |
| 3 | 2.0 | 0 | 0 | | | | |
| 4 | 1.0 | 0.1 | 0 | | | | |
| 5 | 1.0 | 0.1 | 0.05 | | | | |

## 实验六：运动学验证

### 实验目标
1. 验证正运动学计算
2. 测试各种运动模式
3. 校准运动学参数

### 实验步骤

#### 步骤1：基础运动测试
```c
void Kinematics_Basic_Test(void)
{
    Kinematics_Struct kin;
    
    printf("=== 基础运动测试 ===\n");
    
    // 1. 前进
    printf("1. 前进测试\n");
    kin.Linear_X = 0.3;
    kin.Linear_Y = 0.0;
    kin.Angular_Z = 0.0;
    ExecuteMotion(&kin, 2000);
    
    // 2. 后退
    printf("2. 后退测试\n");
    kin.Linear_X = -0.3;
    ExecuteMotion(&kin, 2000);
    
    // 3. 左平移
    printf("3. 左平移测试\n");
    kin.Linear_X = 0.0;
    kin.Linear_Y = 0.3;
    ExecuteMotion(&kin, 2000);
    
    // 4. 旋转
    printf("4. 旋转测试\n");
    kin.Linear_Y = 0.0;
    kin.Angular_Z = 0.5;
    ExecuteMotion(&kin, 2000);
    
    StopAllMotors();
}
```

#### 步骤2：参数校准测试
```c
void Kinematics_Parameter_Calibration(void)
{
    printf("前进1秒测试\n");
    Kinematics_Struct kin = {0};
    kin.Linear_X = 0.5;
    
    ExecuteMotion(&kin, 1000);
    
    printf("请测量实际移动距离\n");
    printf("输入实际距离(米): ");
    float actual_distance;
    // 实际中需要读取用户输入
    
    float expected_distance = 0.5;
    float scale_factor = actual_distance / expected_distance;
    
    printf("校准系数: %.3f\n", scale_factor);
}
```

### 运动测试记录表
| 运动模式 | 理论速度 | 实际表现 | 偏差分析 | 调整建议 |
|----------|---------|---------|---------|---------|
| 前进 | 0.3 m/s | | | |
| 后退 | 0.3 m/s | | | |
| 左平移 | 0.3 m/s | | | |
| 右平移 | 0.3 m/s | | | |
| 顺时针旋转 | 0.5 rad/s | | | |
| 逆时针旋转 | 0.5 rad/s | | | |

## 实验七：IMU数据采集与姿态解算

### 实验目标
1. 读取MPU6050原始数据
2. 实现姿态解算
3. 验证姿态准确性

### 实验步骤

#### 步骤1：原始数据读取
```c
void IMU_RawData_Test(void)
{
    printf("=== MPU6050原始数据测试 ===\n");
    
    MPU6050_Data data;
    
    for(int i=0; i<10; i++) {
        MPU6050_ReadData(&data);
        
        printf("采样%d: ", i+1);
        printf("Accel: X=%.2f, Y=%.2f, Z=%.2f g | ", 
               data.accel_x_g, data.accel_y_g, data.accel_z_g);
        printf("Gyro: X=%.2f, Y=%.2f, Z=%.2f dps\n",
               data.gyro_x_dps, data.gyro_y_dps, data.gyro_z_dps);
        
        HAL_Delay(500);
    }
}
```

#### 步骤2：传感器校准
```c
void IMU_Calibration(void)
{
    printf("=== MPU6050校准 ===\n");
    
    float accel_offset[3] = {0};
    float gyro_offset[3] = {0};
    int samples = 100;
    
    MPU6050_Data data;
    for(int i=0; i<samples; i++) {
        MPU6050_ReadData(&data);
        
        accel_offset[0] += data.accel_x_g;
        accel_offset[1] += data.accel_y_g;
        accel_offset[2] += data.accel_z_g;
        
        gyro_offset[0] += data.gyro_x_dps;
        gyro_offset[1] += data.gyro_y_dps;
        gyro_offset[2] += data.gyro_z_dps;
        
        HAL_Delay(10);
    }
    
    for(int j=0; j<3; j++) {
        accel_offset[j] /= samples;
        gyro_offset[j] /= samples;
    }
    
    accel_offset[2] -= 1.0;
    
    printf("校准结果:\n");
    printf("加速度偏移: X=%.4f, Y=%.4f, Z=%.4f g\n",
           accel_offset[0], accel_offset[1], accel_offset[2]);
    printf("陀螺仪偏移: X=%.4f, Y=%.4f, Z=%.4f dps\n",
           gyro_offset[0], gyro_offset[1], gyro_offset[2]);
}
```

### IMU测试记录表
| 测试项目 | 期望值 | 实测值 | 误差 | 备注 |
|----------|--------|--------|------|------|
| 水平静止Roll | 0° | | | |
| 水平静止Pitch | 0° | | | |
| 倾斜30° Roll | 30° | | | |
| 倾斜30° Pitch | 30° | | | |
| 旋转90° Yaw | 90° | | | |

## 实验八：通信协议测试

### 实验目标
1. 测试串口通信
2. 验证数据协议
3. 实现简单遥控

### 实验步骤

#### 步骤1：串口回环测试
```c
void UART_Loopback_Test(void)
{
    printf("=== 串口回环测试 ===\n");
    
    uint8_t test_data[] = {0x01, 0x02, 0x03, 0x04, 0x05};
    uint8_t receive_buffer[10];
    
    HAL_UART_Transmit(&huart1, test_data, 5, 1000);
    printf("发送: ");
    for(int i=0; i<5; i++) printf("%02X ", test_data[i]);
    printf("\n");
    
    HAL_UART_Receive(&huart1, receive_buffer, 5, 1000);
    printf("接收: ");
    for(int i=0; i<5; i++) printf("%02X ", receive_buffer[i]);
    printf("\n");
    
    if(memcmp(test_data, receive_buffer, 5) == 0) {
        printf("回环测试通过!\n");
    } else {
        printf("回环测试失败!\n");
    }
}
```

#### 步骤2：简单遥控实现
```c
void Simple_Remote_Control(void)
{
    printf("=== 简单遥控测试 ===\n");
    printf("使用串口发送控制指令:\n");
    printf("W - 前进\n");
    printf("S - 后退\n");
    printf("A - 左转\n");
    printf("D - 右转\n");
    printf("Q - 停止\n");
    printf("E - 退出\n");
    
    uint8_t cmd;
    while(1) {
        if(HAL_UART_Receive(&huart1, &cmd, 1, 10) == HAL_OK) {
            switch(cmd) {
                case 'W':
                    printf("前进\n");
                    SetVelocity(0.2, 0, 0);
                    break;
                case 'S':
                    printf("后退\n");
                    SetVelocity(-0.2, 0, 0);
                    break;
                case 'A':
                    printf("左转\n");
                    SetVelocity(0, 0, 0.5);
                    break;
                case 'D':
                    printf("右转\n");
                    SetVelocity(0, 0, -0.5);
                    break;
                case 'Q':
                    printf("停止\n");
                    SetVelocity(0, 0, 0);
                    break;
                case 'E':
                    printf("退出遥控\n");
                    return;
            }
        }
        
        HAL_Delay(10);
    }
}
```

## 实验九：系统集成测试

### 实验目标
1. 集成所有模块
2. 实现完整功能
3. 性能测试与优化

### 实验步骤

#### 步骤1：完整功能测试清单
```c
void System_Integration_Test(void)
{
    printf("=== 系统集成测试 ===\n");
    
    printf("1. 系统初始化检查...\n");
    if(!System_Check_All()) {
        printf("初始化失败!\n");
        return;
    }
    printf("初始化成功\n");
    
    printf("2. 传感器检查...\n");
    Check_Sensors();
    
    printf("3. 电机检查...\n");
    Check_Motors();
    
    printf("4. 通信检查...\n");
    Check_Communication();
    
    printf("5. 运动测试...\n");
    Motion_Test_Suite();
    
    printf("6. 性能测试...\n");
    Performance_Test();
    
    printf("=== 集成测试完成 ===\n");
}
```

#### 步骤2：性能测试
```c
void Performance_Test(void)
{
    printf("性能测试开始\n");
    
    uint32_t start_time, end_time;
    int cycles = 1000;
    
    start_time = HAL_GetTick();
    for(int i=0; i<cycles; i++) {
        Control_Loop_Iteration();
    }
    end_time = HAL_GetTick();
    
    float avg_time = (end_time - start_time) * 1000.0 / cycles;
    printf("平均控制周期: %.2f us\n", avg_time);
    printf("控制频率: %.1f Hz\n", 1000000.0 / avg_time);
}
```

## 实验十：故障诊断与调试

### 实验目标
1. 学习常见故障诊断方法
2. 掌握调试工具使用
3. 建立问题解决流程

### 常见故障案例

#### 案例1：电机不转
**现象**: 设置速度后电机无反应
**诊断步骤**:
1. 检查电源电压
2. 检查PWM信号
3. 检查使能信号
4. 检查电机驱动芯片
5. 检查程序配置

#### 案例2：编码器读数异常
**现象**: 编码器计数不变化或变化异常
**诊断步骤**:
1. 检查编码器供电
2. 检查A/B相信号
3. 检查定时器配置
4. 检查接线是否松动

### 调试工具使用指南

#### 1. 串口调试
```c
#define DEBUG_ENABLE 1

#if DEBUG_ENABLE
#define DEBUG_PRINT(fmt, ...) printf("[DEBUG] " fmt "\n", ##__VA_ARGS__)
#else
#define DEBUG_PRINT(fmt, ...)
#endif

DEBUG_PRINT("电机%d速度: %.2f", motor_id, speed);
```

#### 2. LED状态指示
```c
void LED_Error_Code(uint8_t error_code)
{
    for(int i=0; i<error_code; i++) {
        HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);
        HAL_Delay(200);
        HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
        HAL_Delay(200);
    }
    HAL_Delay(1000);
}
```

## 总结与进阶

### 学习成果检查
完成所有实验后，你应该能够：
- [ ] 独立搭建开发环境
- [ ] 理解各模块工作原理
- [ ] 进行参数校准和调试
- [ ] 诊断常见故障
- [ ] 进行系统集成测试

### 进阶学习方向
1. **算法优化**: 尝试更先进的控制算法
2. **功能扩展**: 添加避障、路径规划等功能
3. **性能提升**: 优化代码效率，提高控制频率
4. **系统集成**: 与ROS系统深度集成
5. **产品化**: 考虑可靠性、安全性和用户体验

### 资源推荐
1. **官方文档**: STM32 HAL库参考手册
2. **在线课程**: 嵌入式系统开发相关课程
3. **开源项目**: GitHub上的机器人项目
4. **社区论坛**: STM32社区、ROS社区

---
*文档版本: 1.0*
*最后更新: 2026年2月*
*作者: Roo技术团队*
